{"version":3,"file":"index.umd.js","sources":["../src/index.mjs"],"sourcesContent":["/**\n * Uses Intersection Observer to monitor the page location of a series of\n * elements for scrollytelling.\n *\n * @param {object} options\n * @param {Element} [options.container] Optionally pass in what should be\n * considered the containing element of all the scenes - this gets added to the\n * Intersection Observer instance and additionally fires its own events\n * @param {Number} [options.offset] How far from the top/bottom of the viewable\n * area to trigger enters/exits of scenes, represented as a value between\n * 0 and 1\n * @param {Element[]} options.scenes An array of all the Elements to be\n * considered scenes of this Scroller\n * @property {IntersectionObserver|null} observer Once initialized, a reference\n * to the Scroller's instance of IntersectionObserver\n * @example\n *\n * import Scroller from '@newswire/scroller';\n *\n * const scroller = new Scroller({\n *   scenes: document.querySelectorAll('.scenes')\n * });\n *\n * scroller.init();\n */\nclass Scroller {\n  constructor({ container, offset = 0.5, scenes }) {\n    // public\n    this.observer = null;\n\n    // private\n    this.all_ = {};\n    this.container_ = container;\n    this.offset_ = offset;\n    this.previousOffset_ = 0;\n    this.scenes_ = scenes;\n  }\n\n  /**\n   * Adds a callback to the queue of a given event listener.\n   *\n   * @param {string} type Name of the event\n   * @param {Function} handler Callback function added to the listener\n   * @returns {void}\n   * @example\n   *\n   * const scroller = new Scroller({\n   *   scenes: document.querySelectorAll('.scenes')\n   * });\n   *\n   * const fn = (...) => {...};\n   *\n   * // adds callback to listener\n   * scroller.on('scene:enter', fn);\n   */\n  on(type, handler) {\n    (this.all_[type] || (this.all_[type] = [])).push(handler);\n  }\n\n  /**\n   * Removes a callback from the queue of a given event listener.\n   *\n   * @param {string} type Name of the event\n   * @param {Function} handler Callback function removed from the listener\n   * @returns {void}\n   * @example\n   *\n   * const scroller = new Scroller({\n   *   scenes: document.querySelectorAll('.scenes')\n   * });\n   *\n   * const fn = (...) => {...};\n   *\n   * // adds callback to listener\n   * scroller.on('scene:enter', fn);\n   *\n   * // removes callback from listener\n   * scroller.off('scene:enter', fn);\n   */\n  off(type, handler) {\n    if (this.all_[type]) {\n      this.all_[type].splice(this.all_[type].indexOf(handler) >>> 0, 1);\n    }\n  }\n\n  /**\n   * Sends a payload to all callback functions listening for a given event.\n   *\n   * @private\n   * @param {string} type Name of the event\n   * @param {*} evt Data to be sent to each callback attached to the listener\n   * @returns {void}\n   */\n  emit_(type, evt) {\n    (this.all_[type] || []).slice().map(handler => {\n      handler(evt);\n    });\n  }\n\n  /**\n   * Initializes a Scroller's IntersectionObserver on a page and begins sending\n   * any intersection events that occur.\n   *\n   * @returns {void}\n   * @example\n   *\n   * const scroller = new Scroller({\n   *   scenes: document.querySelectorAll('.scenes')\n   * });\n   *\n   * scroller.init();\n   */\n  init() {\n    const observed = [];\n\n    this.observer = new IntersectionObserver(\n      entries => {\n        const isScrollingDown = this.getDirection_();\n\n        entries.forEach(entry => {\n          const element = entry.target;\n\n          const payload = {\n            bounds: entry.boundingClientRect,\n            element,\n            index: observed.indexOf(element),\n            isScrollingDown,\n          };\n\n          const prefix = element === this.container_ ? 'container' : 'scene';\n\n          if (entry.isIntersecting) {\n            /**\n             * Container enter event. Fires whenever the container begins intersecting.\n             *\n             * @event Scroller#container:enter\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the active element\n             * @property {Element} element The element that intersected\n             * @property {number} index This is always -1 on the container\n             * @property {boolean} isScrollingDown Whether the user triggered this element\n             * while scrolling down or not\n             */\n            /**\n             * Scene enter event. Fires whenever a scene begins intersecting.\n             *\n             * @event Scroller#scene:enter\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the active element\n             * @property {Element} element The element that intersected\n             * @property {number} index The index of the active element\n             * @property {boolean} isScrollingDown Whether the user triggered this element\n             * while scrolling down or not\n             */\n            this.emit_(`${prefix}:enter`, payload);\n          } else {\n            /**\n             * Container exit event. Fires whenever the container has exited.\n             *\n             * @event Scroller#container:exit\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the exiting element\n             * @property {Element} element The element that exited\n             * @property {number} index This is always -1 on the container\n             * @property {boolean} isScrollingDown Whether the user triggering the exit\n             * while scrolling down or not\n             */\n            /**\n             * Scene enter event. Fires whenever a scene has exited.\n             *\n             * @event Scroller#scene:exit\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the exiting element\n             * @property {Element} element The element that exited\n             * @property {number} index The index of the exiting element\n             * @property {boolean} isScrollingDown Whether the user triggering the exit\n             * while scrolling down or not\n             */\n            this.emit_(`${prefix}:exit`, payload);\n          }\n        });\n      },\n      {\n        rootMargin: `${-100 * (1 - this.offset_)}% 0px ${-100 * this.offset_}%`,\n      }\n    );\n\n    for (let i = 0; i < this.scenes_.length; i++) {\n      const item = this.scenes_[i];\n\n      observed.push(item);\n      this.observer.observe(item);\n    }\n\n    // a container is not required, but if provided we'll track it\n    if (this.container_) this.observer.observe(this.container_);\n\n    /**\n     * Init event. Fires once Scroller has finished setting up.\n     *\n     * @event Scroller#init\n     */\n    this.emit_('init');\n  }\n\n  /**\n   * Determines whether the page was scrolling up or down when an intersection\n   * event is triggered. Keeps track of direction via storage of the previous\n   * pageYOffset.\n   *\n   * @private\n   * @returns {boolean} If true, the page was scrolling down\n   */\n  getDirection_() {\n    const currentOffset = window.pageYOffset;\n\n    const isScrollingDown = currentOffset > this.previousOffset_;\n    this.previousOffset_ = currentOffset;\n\n    return isScrollingDown;\n  }\n}\n\nexport default Scroller;\n"],"names":["container","offset","scenes","this","observer","all_","container_","offset_","previousOffset_","scenes_","on","type","handler","push","off","splice","indexOf","emit_","evt","slice","map","init","observed","IntersectionObserver","entries","isScrollingDown","_this","getDirection_","forEach","entry","element","target","payload","bounds","boundingClientRect","index","prefix","isIntersecting","rootMargin","i","length","item","observe","currentOffset","window","pageYOffset"],"mappings":"6OA0BE,kBAAcA,IAAAA,cAAWC,OAAAA,aAAS,KAAKC,IAAAA,OAErCC,KAAKC,SAAW,KAGhBD,KAAKE,EAAO,GACZF,KAAKG,EAAaN,EAClBG,KAAKI,EAAUN,EACfE,KAAKK,EAAkB,EACvBL,KAAKM,EAAUP,6BAoBjBQ,GAAA,SAAGC,EAAMC,IACNT,KAAKE,EAAKM,KAAUR,KAAKE,EAAKM,GAAQ,KAAKE,KAAKD,MAuBnDE,IAAA,SAAIH,EAAMC,GACJT,KAAKE,EAAKM,IACZR,KAAKE,EAAKM,GAAMI,OAAOZ,KAAKE,EAAKM,GAAMK,QAAQJ,KAAa,EAAG,MAYnEK,EAAA,SAAMN,EAAMO,IACTf,KAAKE,EAAKM,IAAS,IAAIQ,QAAQC,IAAI,SAAAR,GAClCA,EAAQM,QAiBZG,KAAA,sBACQC,EAAW,GAEjBnB,KAAKC,SAAW,IAAImB,qBAClB,SAAAC,GACE,IAAMC,EAAkBC,EAAKC,IAE7BH,EAAQI,QAAQ,SAAAC,GACd,IAAMC,EAAUD,EAAME,OAEhBC,EAAU,CACdC,OAAQJ,EAAMK,mBACdJ,QAAAA,EACAK,MAAOb,EAASN,QAAQc,GACxBL,gBAAAA,GAGIW,EAASN,IAAYJ,EAAKpB,EAAa,YAAc,QAyBzDoB,EAAKT,EAvBHY,EAAMQ,eAuBMD,WAwBAA,UAxBgBJ,MA4BpC,CACEM,YAAgB,KAAO,EAAInC,KAAKI,aAAkB,IAAMJ,KAAKI,QAIjE,IAAK,IAAIgC,EAAI,EAAGA,EAAIpC,KAAKM,EAAQ+B,OAAQD,IAAK,CAC5C,IAAME,EAAOtC,KAAKM,EAAQ8B,GAE1BjB,EAAST,KAAK4B,GACdtC,KAAKC,SAASsC,QAAQD,GAIpBtC,KAAKG,GAAYH,KAAKC,SAASsC,QAAQvC,KAAKG,GAOhDH,KAAKc,EAAM,WAWbU,EAAA,WACE,IAAMgB,EAAgBC,OAAOC,YAEvBpB,EAAkBkB,EAAgBxC,KAAKK,EAG7C,OAFAL,KAAKK,EAAkBmC,EAEhBlB"}